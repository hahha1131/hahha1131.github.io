I"	<h2 id="분할-정복-알고리즘">분할 정복 알고리즘</h2>
<ul>
  <li>분할 정복 알고리즘이란 단 한 번으로 동시에 해결하기 어려운 문제를 더 이상 나눌 수 없을 정도의 문제로 나누어 각각 해답을 얻은 후 다시 병합하여 문제를 해결하는 알고리즘이다.</li>
  <li>단순히 분할만 해서는 문제를 해결할 수 없고, 알고리즘의 이름과 같이 분할을 한 문제들을 ‘정복’해야 한다.</li>
</ul>

<h2 id="분할-정복-알고리즘의-분류">분할 정복 알고리즘의 분류</h2>
<h3 id="합병-정렬">합병 정렬</h3>
<ul>
  <li>합병 정렬(Merge Sort)은 입력이 2개의 부분문제로 분할이 되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.</li>
  <li>입력된 N을 N/2개씩 2개의 문제로 분할하고, 각각의 문제를 합병 정렬한 후, 2개의 정렬된 부분을 합병하여 정렬한다. 즉, 합병 과정이 문제를 정복하는 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//합병 정렬 알고리즘
MergeSort(A,p,q)
입력 A[p]~A[q]
출력 정렬된 A[p]~A[q]
if (p &lt; q) {                // 배열의 원소의 수가 2개 이상이면
 k = [(p+q)/2]           // k = 배열을 반으로 나누기 위한 인덱스
 MergeSort(A,p,k)        // 앞부분 순환 호출
 MergeSort(A,k+1,~q)     // 뒷부분 순환 호출
 A[p]~A[k], A[k+1]~A[q]를 합병
}
</code></pre></div></div>

<ul>
  <li>if문에서는 정렬한 부분의 원소가 2개 이상일 때 수행되도록 함</li>
  <li>정렬할 부분의 원소들을 1/2로 나누기 위해 k의 값을 계산</li>
  <li>MergeSort를 호출하여 각각 정렬</li>
  <li>
    <p>임시 배열을 이용하여 임시 배열에 정렬되어 있던 값을 복사하는 방식으로 두 배열을 합병</p>
  </li>
  <li>합병 정렬의 시간복잡도는 (층수) X O(N) = log 2 n X O(N) = O(NlogN)이다.</li>
  <li>합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때에도 퀵 정렬이나 합 정렬보다 훨씬 효율적이다.</li>
  <li>정렬 알고리즘을 병렬화하는 데에 합병 정렬 알고리즘이 활용된다. (ex&gt; 멀티코어 CPU, 다수의 프로세서로 구성된 그래픽 처리 장치)</li>
</ul>

:ET