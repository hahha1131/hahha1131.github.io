I"<h2 id="분할-정복-알고리즘">분할 정복 알고리즘</h2>
<ul>
  <li>분할 정복 알고리즘이란 단 한 번으로 동시에 해결하기 어려운 문제를 더 이상 나눌 수 없을 정도의 문제로 나누어 각각 해답을 얻은 후 다시 병합하여 문제를 해결하는 알고리즘이다.</li>
  <li>단순히 분할만 해서는 문제를 해결할 수 없고, 알고리즘의 이름과 같이 분할을 한 문제들을 <strong>정복</strong>해야 한다.</li>
</ul>

<hr />
<h2 id="분할-정복-알고리즘의-분류">분할 정복 알고리즘의 분류</h2>
<h3 id="합병-정렬">합병 정렬</h3>
<ul>
  <li>합병 정렬(Merge Sort)은 입력이 2개의 부분문제로 분할이 되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.</li>
  <li>입력된 N을 N/2개씩 2개의 문제로 분할하고, 각각의 문제를 합병 정렬한 후, 2개의 정렬된 부분을 합병하여 정렬한다. 즉, 합병 과정이 문제를 정복하는 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//합병 정렬 알고리즘
MergeSort(A,p,q)
입력 A[p]~A[q]
출력 정렬된 A[p]~A[q]
if (p &lt; q) {                // 배열의 원소의 수가 2개 이상이면
    k = [(p+q)/2]           // k = 배열을 반으로 나누기 위한 인덱스
    MergeSort(A,p,k)        // 앞부분 순환 호출
    MergeSort(A,k+1,~q)     // 뒷부분 순환 호출
    A[p]~A[k], A[k+1]~A[q]를 합병
}
</code></pre></div></div>

<ul>
  <li>if문에서는 정렬한 부분의 원소가 2개 이상일 때 수행되도록 함</li>
  <li>정렬할 부분의 원소들을 1/2로 나누기 위해 k의 값을 계산</li>
  <li>MergeSort를 호출하여 각각 정렬</li>
  <li>임시 배열을 이용하여 임시 배열에 정렬되어 있던 값을 복사하는 방식으로 두 배열을 합병</li>
</ul>

<hr />
<ul>
  <li>합병 정렬의 시간복잡도는 (층수) X O(N) = log 2 n X O(N) = O(NlogN)이다.</li>
  <li>합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때에도 퀵 정렬이나 합 정렬보다 훨씬 효율적이다.</li>
  <li>정렬 알고리즘을 병렬화하는 데에 합병 정렬 알고리즘이 활용된다. (ex&gt; 멀티코어 CPU, 다수의 프로세서로 구성된 그래픽 처리 장치)</li>
</ul>

<hr />
<h3 id="퀵-정렬">퀵 정렬</h3>
<ul>
  <li>퀵 정렬(Quick Sort)은 분할 정복 알고리즘으로 분류되지만, 수행되는 과정을 살펴보면 정북 후에 분할을 하는 알고리즘이다.</li>
  <li>퀵 정렬은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다.</li>
  <li>퀵 정렬은 피봇(pivot)이라는 배열의 원소(숫자)를 기준으로 피봇보다 작은 숫자들은 왼쪽, 큰 숫자들은 오른쪽에 위치하도록 분할하고, 피봇을 그 사이에 놓는 방식이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//퀵 정렬 알고리즘
QuickSort(A,L,R) //(L은 Left, R은 Right)
입력: 배열 A[L]~A[R]
출력: 정렬된 배열 A[L]~A[R]

if(L &lt; R){
    A[L]~A[R] 중에서 피봇을 선택하고 피봇을 A[L]과 위치를 바꾼 후, 
    피봇과 배열의 원소들을 각각 비교한 후 피봇보다 작은 숫자들은 A[L]~A[p-1]로,
    피봇보다 큰 숫자들은 A[p+1]~A[R]로 옮기며, 피봇은 A[p]에 위치시킨다.
    (p는 피봇{pivot})
    QuickSort(A,L,p-1)  //피봇보다 작은 배열
    QuickSort(A,p+1,R)  //피봇보다 큰 배열
}
</code></pre></div></div>

<ul>
  <li>if문에서는 L이 R보다 작으면 그 밑의 과정들을 실행한다. 만약 그렇지 않다면 L = R인 것이므로, 더 이상 분할할 수 없는, 1개의 원소를 정렬하는 것이 되므로 밑의 과정을 실행하지 않고 끝낸다.</li>
  <li>if문과 QuickSort 사이의 부분에서는 배열의 원소들 중 피봇(기준값)을 정하고 피봇을 기준으로 작은 값들을 A[L]에서 A[p-1]까지, 피봇을 기준으로 큰 값들을 A[p+1]에서 A[R]에 위치시킨다. p는 피봇이 위치하게 되는 배열 A의 인덱스이다.</li>
  <li>QuickSort(A,L,p-1)는 피봇보다 작은 그룹을 순환적으로 호출</li>
  <li>QuickSort(A,p+1,R)는 피봇보다 큰 그룹을 순환적으로 호출</li>
</ul>

<hr />
<ul>
  <li>퀵 정렬의 성능은 피봇의 값이 좌우한다. 피봇을 너무 작거나 큰 숫자로 선택하면, 균형이 맞지 않는 분할이 발생할 수 있다.</li>
  <li>가장 이상적인 피봇을 선택됐을 때의 시간복잡도를 계산하면, O(n) X (층수) = O(n) X (log2n)이다. 따라서 퀵 정렬의 시간복잡도는 O(nlog2n)이다.</li>
</ul>

<hr />
<h4 id="피봇-선정-방법">피봇 선정 방법</h4>
<ul>
  <li>3 숫자의 중앙값으로 선정: 가장 왼쪽, 중앙, 가장 오른쪽 숫자 중에서 중앙값으로 정한다.</li>
  <li>중앙값들 중의 중앙값: 입력을 3등분하여 각 부분에서 숫자의 중앙값을 찾아 3개의 중앙값에서 중앙값을 피봇으로 삼는다.</li>
  <li>퀵 정렬은 실질적으로 어느 정렬 알고리즘보다 좋은 성능을 보인다. 또한 생물 정보 공학에서 특정 유전자를 찾는 데 접미 배열과 함께 퀵 정렬이 활용된다.</li>
</ul>

<hr />
<h3 id="분할-정복-알고리즘-문제">분할 정복 알고리즘 문제</h3>
<ul>
  <li>퀵 정렬 알고리즘 문제로 포스팅을 마무리하려 한다. 문제는 교재 p.74에 나와있는 예제이다. (조금씩 숫자를 변경함)</li>
</ul>

<h4 id="quicksorta-0-10-호출">QuickSort(A, 0, 10) 호출</h4>
<ul>
  <li>배열 A를 인덱스 0~10까지 만든다. 각 인덱스에는</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| 0 | 1 |  2 | 3 |  4 | 5 | 6 |  7 |  8 | 9 | 10 |
|---|---|----|---|----|---|---|----|----|---|----|
| 5 | 2 | 10 | 8 | 11 | 1 | 7 | 14 | 17 | 9 |  6 |
</code></pre></div></div>

<ul>
  <li>앞서 언급했던 3 숫자의 중앙값으로 선정하는 방법으로 피봇을 5로 설정한다.</li>
</ul>
:ET