---
layout: post
title:  "분할 정복 알고리즘 (2)"
date:   2022-03-22 12:00:00 +0900
categories: post
---

## 분할 정복 알고리즘  
 바로 전 포스팅으로 분할 정복 알고리즘을 했으나, 
이번 포스팅은 내가 고등학교 프로그래밍 동아리를 들어갈 때 테스트 문제로 했던 가짜 동전 찾기 문제를 다시 풀어보며 
분할 정복 알고리즘에 대해 복습하려 한다.  
 
___

### 가짜 동전 찾기
* 전체적인 문제는 과거 동아리 선배들이 주던 문제의 형식을 따른다.  
* 일단 문제의 기본 조건을 살펴보자면  
    * 동전이 10개 있다.  
    * 진짜 동전의 무게는 10이다.  
    * 가짜 동전은 진짜 동전보다 무게가 3만큼 가볍다. (가짜 동전의 무게: 7)  
    * 저울을 처음 사용할 때, 무게의 차이를 표시하는 데에 걸리는 시간은 0이다. (결과가 바로 표시됨)  
    * 양팔저울은 계속 사용할 수 있으나, 저울을 사용할 때마다 비교값을 표시하는 시간이 1분씩 증가한다.  
    * 최종적으로 가짜 동전을 판별하는 데에 발생한 저울 사용 횟수와 시간이 적을수록 더 큰 보상을 받는다.  
    
___

 그 당시에 저 문제를 받았을 때에는 분할 정복을 사용하라는 말이 없었고, 나도 본격적으로 알고리즘 공부를 하지 않았던 때라서 
정말 다양한 방법으로, 어쩌면 비효율적인 방법들로 문제를 해결하려고 시도했었다.  

내가 시도했던 방법들을 일부 나열하면  
* 양팔저울의 양쪽에 동전을 하나씩 비교하여 찾는 방법  
* 동전을 2개씩 묶어 한 번에 총 4개씩 비교하는 방법  
* 하나의 동전을 한쪽에 고정시켜 나머지 동전을 비교하는 방법  

 위의 방법 외에도 다른 방법도 많았지만, 대부분의 과정이 거의 비슷했다. 저 방법을 이용하여 풀었을 때 동아리 선배들은 다양하게 풀기는 했지만, 
가장 효율적인 방법을 찾지는 못했다고 하며 분할 정복 알고리즘에 대해 알려주었다.  

___
### 동전 찾기  
* 적어도 내가 아는 방법 중 가장 효율적으로 보였던 방법을 풀어보겠다.  
    * 동전을 5개씩, 2묶음으로 나눈다. 2묶음의 차이를 비교하기 위해 한 번 저울을 사용한다.  
    * 더 가벼운 묶음에 가짜 동전이 있는 것으로 판단하고, 더 무거운 묶음의 동전 5개는 제외한다.  
    * 가짜 동전이 있는 묶음에는 5개의 동전이 있기에 동전을 하나 임시로 제외하고 2개씩 나누어 2묶음으로 나눈다.  
        * 여기서 결과가 2개로 나누어지는데  
            * 만약 2묶음의 무게가 같다면, 방금 임시로 제외한 동전이 가짜 동전이 된다.  
            * 2개의 묶음 중 가벼운 묶음이 있다면, 그 묶음에 가짜 동전이 있는 것이 된다.  
    * 만약 제외했던 동전이 가짜가 된다면, 알고리즘은 여기서 끝이 난다.  
    * 위의 상황이 아니라면, 더 가벼운 묶음으로 판별된 2개의 동전의 무게를 비교하여 가짜 동전을 찾는다.  

___

 위 풀이를 보고 난 후, 동아리 선배들이 어떤 언어든 좋으니 가장 자신있는 언어로 해당 알고리즘을 프로그램으로 구현하라는 개인 과제를 받았었다. 
그나마 자신있었던 언어가 C였기에 C로 구현했었고, 동아리에 합격할 수 있었다.  
    
소스코드를 보자면  

~~~c
#include <stdio.h>
int main(){
	int coin[10]; //coin 배열 생성
	int tempA[10]; //임시배열 생성 
	int tempB[10]; //임시배열 생성 
	int i, j, k; //정수 i, j, k 생성 
	int sumA, sumB = 0; //묶음의 무게 합 
	
	// coin 배열 원소 10으로 초기화, 임시 배열 원소 0으로 초기화 
	for(int i = 0; i < 10; i++){
		coin[i] = 10;
		tempA[i] = 0;
		tempB[i] = 0;
	}
	
	coin[3] = 7; // 가짜 동전 무게 7로 설정 
		
	// 10개의 동전을 5개씩 2그룹으로 분리
	for(int i = 0; i < 5; i++){
		tempA[i] = coin[i];
		sumA += tempA[i]; // 그룹 원소들의 합
	}
	printf("First group's weight: %d\n", sumA);
	
	for(int j = 5; j < 10; j++){
		tempB[j] = coin[j];
		sumB += tempB[j];
	}
	printf("Second group's weight : %d\n", sumB);
	
	if(sumA < sumB) {
		printf("\nFake coin is in First group.\n\n");
		
		for(i = 0; i < 5; i++){ // 임시배열 초기화 
			tempA[i] = 0;
			tempB[i] = 0;
		}
		sumA = 0; 
		sumB = 0; // 그룹합 초기화 
		
		// tempA에 가짜 동전이 있기에 tempA를 다시 분리 
		for(j = 0; j < 2; j++) {
			tempA[j] = coin[j];
			sumA += tempA[j];
		}
		printf("tempA's weight: %d\n", sumA);
			
		for(k = 2; k < 4; k++){
			tempB[k] = coin[k];
			sumB += tempB[k];
		}
		printf("tempB's weight: %d\n\n", sumB);
		
		// 한 그룹에 동전이 2개라면 가짜 동전이 어디있는지 알 수 있음 
		if(sumA < sumB){
			printf("Fake coin is in tempA.\n\n");
		}
		else if(sumA > sumB){
			printf("Fake coin is in tempB.\n\n");
			
			if(tempB[2] < tempB[3]){
				printf("Fake coin is tempB[2], coin[3].\n");
			}
			else
				printf("Fake coin is tempB[3], coin[3].\n");
		}
		else if(sumA = sumB)
			printf("Fake coin is coin [9.]\n");
		else
			printf("error\n");
	}
	
	return 0;
} 
~~~

___

* 위의 소스코드에서는 가짜 동전의 위치가 정해져 있기 때문에 몇몇 부분을 생략하여 간단하게 표현했지만, 
실제로는 더 많은 코드가 필요할 것이다. 그리고 고등학교 시절 기준으로 코드를 쓴 것이기 때문에 함수를 활용하지 않았다.(고등학생 때는 함수를 활용하지 못했기 때문이다) 따라서 함수를 이용하여 더 간결하게 쓸 수 있는 부분도 있다.  
  
* 그러나 어느 부분에서 그룹이 나누어지고(분할) 어떻게 가짜 동전의 위치를 파악(정복)하는지 보기에는 충분한 코드가 아니었을까 싶다.